---
layout: post
title: 浏览器客户端识别技术概况
tags: browser,identification
desc: 译文：客户端识别机制技术分析，来自 Chromium Security
--- 

[原文: Technical analysis of client identification mechanisms](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/client-identification-mechanisms)

通常来说，**网络跟踪**（Web Tracking）是指的是一个过程，该过程会把通过**计算或分配**得来的 ID 存储到每一个访问网站的浏览器。
这样做的主要目的是想把用户（或设备）的访问行为和信息通过这个 ID 关联起来，并以此来分析用户，比如个人喜好，因此要求这个 ID 必须具有**唯一性和稳定性**。

目前，一些网络跟踪技术已经相当成熟并且很普遍。常见应用如：

* 用于区分真实用户和恶意机器人
* 增加攻击者侵入用户账户的难度
* 存储用户在网站的个人偏好设置

其中，应用最广的当属在线广告行业，自 90 年代中期开始，它就把 Cookie 作为主要的客户端识别技术。
除此之外，其他的识别技术则鲜为人知，因为它们可能并不直接跟浏览器控件相关，也可能是因为隐藏得太深而至今尚未被发现。
与此同时，也还有一些识别技术已经引起了软件供应商、标准组织和媒体的担忧，尤其是各种客户端指纹（Fingerprint）技术。

为了有效控制浏览器控件的功能范围，同时突出潜在的新 API 设计隐患，我们决定对浏览器端现有的跟踪和指纹技术做一个技术调研。
要强调的是，虽然我们在这里讨论这些技术，但是我们并**不号召**大家去使用它们。
所有网站的拥有者都应该清楚，任何跟踪技术都可能引起用户的不爽，因为它违背了用户意愿或者其他本文未覆盖到的复杂因素。

下文中，我们把跟踪技术分为以下三类：

* 分配类，如 HTTP Cookie ，会明确地给客户端分配一个 ID 
* 设备类，利用客户端设备的固有特征来识别特定机器
* 行为类，利用键盘（或触摸屏）背后用户的行为和偏好来识别

在分析完这些跟踪和指纹技术之后，我们还会讨论未来可能的工作方向，并且总结浏览器和其他软件厂商在检测或阻止这类网络行为时可能面临的挑战。

## 分配类

HTTP 请求本身是无状态的，要想把多个 HTTP 请求关联起来，最典型的做法是在客户端存储一个唯一的、持久的令牌，然后在后续的请求中获取该令牌。现代浏览器提供了多种方式来实现这个想法，包括但不限于：

* 广为人知的 [HTTP Cookie](http://tools.ietf.org/html/rfc6265)
* 类 Cookie 的插件功能，例如 Flash 的[本地共享对象](http://en.wikipedia.org/wiki/Local_shared_object)（Local Shared Objects）和 Silverlight 的[独立存储](http://msdn.microsoft.com/en-us/magazine/dd458794.aspx)（Isolated Storage）
* HTML5 客户端存储机制，包括 [localStorage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage)、[File](https://developer.mozilla.org/en-US/docs/Web/API/File) 和 [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
* 本地缓存资源或其元数据中包含的独特标记，如 Last-Modified 和 ETag
* 从浏览器 SSL [域名证书](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final162.pdf)中衍生出来的指纹
* [HSTS](http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) 主机名列表中的位编码
* [SDCH](http://en.wikipedia.org/wiki/Shared_Dictionary_Compression_Over_HTTP) 压缩字典和字典元数据中的数据编码

我们相信，以上任意一种方法都足够可靠地标记并识别用户。除此之外，许多类似的标记都在以某种方式运行着，虽然它们看起来可能并不具备唯一性。另一方面，除了稍后要讨论到的几个例外，浏览器也赋予了用户控制这些 API 行为的能力，以防这类标记方式不会扩散到其他浏览器配置文件或私有浏览会话。

本章节接下来的部分，我们会在 Web 应用范围内更加深入地介绍这些客户端标记方法。

### HTTP Cookie

HTTP Cookie 是最典型的浏览器客户端数据存储方式。
实际上，当用户第一次访问网站时，大部分 Web 服务器都会以 HTTP 响应的方式为用户分配一个唯一标识。用户在未来继续访问时，浏览器便会把这个唯一标识通过 HTTP 请求传回给该网站。

多年来，所有主流的浏览器都提供了管理 Cookie 的界面。同时，也涌现出一大批第三方 Cookie 管理工具和阻拦软件。但实际上，有研究曾暗示，只有少数的用户会定期检查或清除 Cookie 。其原因可能是复杂多样的，但其中最主要的原因可能是删除 Cookie 往往会导致破坏性的结果。因为现代浏览器并没有提供任何方式来区分用作用户登录的会话 Cookie 和用作其它用途的 Cookie 。要删的话，所有 Cookie 都会一视同仁地被清除。

一些浏览器也为用户提供了可配置功能，用来限制网站设置第三方 Cookie 。所谓第三方是指当前网站域名以外的其它域名。这种设置第三方 Cookie 的做法，其目的一般用于在线广告或其它需要嵌入式的内容。
要注意的是，这种设置的实现方式会把以下页面或内容设置的所有 Cookie 标记为“第一方”：

* 用户有意跳转页面
* 整页的插入式广告页面中浏览器加载的部分内容
* HTTP 重定向加载的页面
* 点击触发的弹窗页面

与下面要讨论的其它技术相比，公开使用的 HTTP Cookie 对用户来说是相当透明的。
虽然有些网站不直接使用看起来具有唯一性的 Cookie 来标记用户，但是却通过变相地方式用来标记用户。
比如，设置多个看起来无关的而且合理的 Cookie 名称，但是把它们组合起来却能得到唯一的标记；又比如，把具有唯一性的标记存储在 Cookie 的路径、域名或者过期时间等元数据中。
正因为这些方式的隐蔽性，我们才没有意识到浏览器还是可以通过 Cookie 来可靠地标记特定用户。

一个有趣的现象是，如果每个网站都设置 Cookie ，那么同一个客户端就可能存有大量的 Cookie 。这意味着一个网站可以依赖别人设置的 Cookie ，而不需要自己重新设置一个可以直接被追踪到的新 Cookie 。
我们在一些丰富内容的广告中发现过这种现象：这些广告位于一个相同的域名下，但这个域名却被所有的广告商共享，或者更夸张的说，直接在广告所嵌入的页面中运行用于标记用户的相关代码。


### Flash 本地共享对象

[**本地共享对象**](http://www.adobe.com/security/flashplayer/articles/lso/)（LSO）是 Adobe Flash 的典型客户端存储方式。
这种机制被设计为 HTTP Cookie 的直接副本，提供一种简便的方式去操作会话标识，以及其他针对单个源的应用状态。
相比于 Cookie ，LSO 还可以用来存储结构化数据，而不仅仅是简短的文本片段。
结构化存储的数据可以设计得更加复杂，使得更难以被分析，起到一定的保护作用。

过去，Flash 插件的 LSO 存储行为配置必须从浏览器隐私设置中独立出来，以一种更少见的方式 Flash 设置管理 UI 来设置。
今天，大部分浏览器提供了一定程度的集成。比如，清除 Cookie 和其他网站数据时通常会将 LSO 一并移除。
另一方面，更加细微的控制则可能不同步，也就是说，第三方的 Cookie 设置并不总是反应在 LSO 的行为中。

从纯粹的技术角度来说，LSO 跟 Cookie 在 API 参数的使用方式上存在一定的相似性。但是依赖 LSO 来重建已被删除的 Cookie 行为或者绕过浏览器 Cookie 偏好设置的行为，已经受到公众的详细审查。

目前，Flash 的使用已经非常少见了。

### Silverlight 隔离存储

### HTML5 客户端存储

HTML5 引进了一系列的客户端结构化存储机制，包括 localStorage、File API 和 IndexedDB。
虽然从语义上来说它们互相区别，但是它们都是被设计来持久化存储任意二进制数据块。
与 Cookie 和 LSO 相比，浏览器没有严格地限制它们的存储空间。

在现代浏览器中，清除 HTML5 存储的数据只会影响到当前源，不影响其他网站源。
但是这种行为在浏览器设置中却没有明显的体现。
比如，Firefox 会继续保持 localStorage 的数据除非用户选择了在弹出的删除框中勾选删除选项。
再比如，在打开操作发生时，IE 会一直保留在同一个标签页中打开的所有网站数据。

此外，这种存储机制并不总是遵守持久化存储的同源限制。
比如，在我们的测试中，如果第三方源的 Cookie 被禁用了，那么 Firefox 的 localStorage 能够被跨域的框架读写。

出于相似的 API 设计目标，笔者对使用 HTML5 来存储会话标识的看法和注意事项与 Flash 和 Silverlight 相同。

### 缓存对象

出于性能考虑，所有主流浏览器都维护这一个全局缓存，用于缓存先前已经下载的 HTTP 资源。
虽然这个缓存机制并不是被设计用来作为一个随机存取的存储方式，但是它却可以被用来实现这个功能。
当然，仅仅靠缓存是不够的，它还需要一台与之配合的服务器。
该服务器用来返回一段嵌入了唯一标识的 JS 代码，并且把 `Expires` `max-age` 等头部设置为很长的过期时间。

当这段 JS 代码被浏览器缓存，它包含的唯一标识就可以被互联网上任何一个加载它的页面所获取。
浏览器将会定期检查是否存在较新副本，方法是使用合适的 `If-Modified-Since` 头部向服务器发起验证请求。
如果服务器始终响应 304 的话，那么缓存的唯一标识将被继续复用。

截止到本文，据我（作者）所知还没有任何关于阻挡"第三方"缓存对象的想法被提出来，而且在不降低浏览器性能的条件下，也没有禁用缓存的简单办法。
自动检测这种行为也是非常难实现的，因为现代浏览器中现存有数量庞大而且复杂的已缓存 JS 文档。

所有浏览器都提供了手动清除缓存的操作。
这就意味着，由于清空缓存需要用户进行额外的主动操作，因此缓存不可能被经常清空，甚至根本不会被清空。

以上分析可以看出，使用浏览器缓存来保存会话标识的方式与 Cookie 大为不同。

### 缓存元数据：ETag 和 Last-Modified

为了让浏览器层的资源缓存正常工作，服务器必须要有一种办法来通知浏览器什么时候该更新缓存资源。
为此，HTTP/1.1 标准制定了两种将文档版本化的办法：一种基于最近修改时间，另一种基于文档内容生成的标识符 `ETag` 。

ETag 方法中，服务端会在返回文档资源的同时在头部返回一个作为版本标签的字符串。
接下来请求相同资源时，客户端会把这个版本标签通过 `If-None-Match` 头部返回给服务器。
如果服务器发现收到的这个版本标签与自己手中的一致，那么就返回 `304` 告诉客户端继续使用缓存文档。
如果不一致，则新文档和新 `ETag` 会发给客户端。

有趣的是，`ETag` 头部的使用机制是模仿 Cookie 的：服务器能够在客户端存储一个任意的、持久的值到客户端，并且以后还可以把它读取回来。这种利用 ETag 来存储数据的应用[最早可以追溯到 2000 年](http://seclists.org/bugtraq/2000/Mar/331)。

另一种版本化的方法，使用 `Last-Modified` 头部，用法与 `ETag` 类似：服务器可以存储至少 32 位数据到一个格式化好的时间字符串中，该字符串也会在未来的相同请求中使用 `If-Modified-Since` 传回给服务器。
其实，在最开始的阶段时，浏览器甚至都不要求该字符串必须是特定格式的时间字符串。

跟使用缓存资源来标记用户类似，删除 Cookie 和其他网站相关数据时，`ETag` 和 `Last-Modified` 这两种元数据都不会受到影响。它们只会在清除浏览器缓存时被清除。

### HTML5 AppCache

应用缓存（Application Cache）允许网站主指定网站的部分资源存储在客户端，并且在用户处于断网的情况下仍然可以使用这些资源。
这种行为是用过[缓存清单](http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#manifests)来控制的，它描述了应用中可以被存储和通过缓存获取的资源项。

跟隐秘的浏览器缓存类似，AppCache 使得我们可以存储唯一的、用户相关的数据。它可以存储在缓存清单本身中，或者存储在缓存清单列出的请求资源中。这些缓存资源可以被永久保存，而且不会受到浏览器缓存驱逐策略的束缚。

相比于 HTML5 客户端存储和浏览器缓存，AppCache 似乎处于一种尴尬的地位。在一些浏览器中，它会在清除 Cookie 时一并清除；在另外一些浏览器中，它只会在清除浏览记录和缓存时一并清除。

### 其他存储方式

也还有其他几种更受限的技术，可以帮助我们使用 JS 来维持和查询客户端状态。
这种方式有时可以帮助我们从清除 Cookie 的操作中逃生。

举个例子，可以使用 `window.name` 和 `sessionStorage` 来存储当前窗口的标识符。
只要用户没有关闭当前标签页，不管用户如何清除 Cookie 等网站数据，从该标签页导航过去的网站都可以取得与之绑定的数据。

更具体的说，运行中的 JS 也具备这种存储功能：我们可以从任何运行中的 JS 上下文获取状态，即使用户此时尝试去删除网站数据。
其实就相当于存储在内存中。

另一种有趣但是被经常忽视的存储机制是 [RFC 2617](http://tools.ietf.org/html/rfc2617) 规定的HTTP 认证凭证缓存。一旦用户明确的登录成功了，那么缓存的认证凭证就会在以后的请求中自动发送，即使用户手动删除所有网站数据。

除了前文谈到的跨浏览器识别方法，还有一些专有 API 可以用来存储唯一标识。
一个有趣的例子是，一些版本的 IE 专有存储行为，比如 [`userData` API](http://msdn.microsoft.com/en-us/library/ms531424(VS.85).aspx)。

也有一些浏览器插件会提供数据存储功能，比如 Java 的 [PersistenceService API](http://docs.oracle.com/javase/7/docs/jre/api/javaws/jnlp/javax/jnlp/PersistenceService.html)。
### 底层协议标识

现代浏览器在网络层提供的相关功能给标记用户提供了可乘之机：

* 源站绑定证书

## 设备类

有一些不太明显的跟踪方法是通过查询或者间接测量客户端系统的特性来实现的。
在这些方法中，每一个特征可能只提供一丁点儿信息，但是如果把所有特征都结合在一起，就可能生成一个唯一的标识。
这种方式除了具有难以发现和难以制止之外，它们可以被用来交叉关联用户跨浏览器设置或者隐私浏览会话的活动。

通过把低区别性的数据组合在一起，形成一个高精度的指纹的典型例子是 [Panopticlick](https://panopticlick.eff.org/browser-uniqueness.pdf)
### 浏览器指纹


### 网络配置指纹



## 行为类


## 参考文章

* [浅谈Web客户端追踪](http://www.freebuf.com/articles/web/127266.html)
